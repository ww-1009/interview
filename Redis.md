# [认识 Redis](https://xiaolincoding.com/redis/)
## 什么是Redis
> Redis 是一种基于**内存**的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存**，**消息队列**、**分布式锁**等场景。

**Redis 提供了多种数据类型**,并且对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。
* String(字符串)
* Hash(哈希)
* List (列表)
* Set(集合)
* Zset(有序集合)
* Bitmaps（位图）
* HyperLogLog（基数统计）
* GEO（地理信息）
* Stream（流）

Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。

## 为什么用 Redis 作为 MySQL 的缓存？
### Redis 具备高性能
假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

![redis-cache-mysql](https://raw.githubusercontent.com/ww-1009/interview/main/img/redis/redis_as_cache_mysql.webp)

### Redis 具备高并发
单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。

所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

# Redis 数据结构
## Redis 数据类型以及使用场景分别是什么？
Redis 提供了丰富的数据类型，常见的有五种数据类型：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）**。

|   结构类型   |                 结构存储的值                 |                                                               结构的读写能力                                                               |
| :----------: | :------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------: |
| String字符串 |          可以是字符串、整数或浮点数          |                                   对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作                                   |
|   List列表   | 一个列表，链表上的每一个节点都包含一个字符串 |                                  对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素                                   |
|   Set集合    |             包含字符串的无序集合             |                        字符串的集合，包含基础的方法有看是否存在添加、添加、获取、删除；还包含计算交集、并集、差集等                        |
|   Hash散列   |           包包含键值对的无序散列表           |                                                     包含方法有添加、获取、删除单个元素                                                     |
| Zset有序集合 |           和散列一样，用于存储键值           | 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素。 |

* String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
* List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
* Hash 类型：缓存对象、购物车等。
* Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
* Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

Redis 后续版本又支持四种数据类型，它们的应用场景如下：

* BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
* HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
* GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
* Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

# Redis 线程模型
## Redis 是单线程吗？
> **Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**，这也是我们常说 Redis 是单线程的原因。

但是，**Redis 程序并不是单线程的**，Redis 在启动的时候，是会**启动后台线程**（BIO）的：

* **Redis 在 2.6 版本**，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；
* **Redis 在 4.0 版本之后**，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 `unlink key / flushdb async / flushall async` 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 `unlink` 命令来异步删除大key。

之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

![redis-cache-mysql](https://raw.githubusercontent.com/ww-1009/interview/main/img/redis/background_thread.webp)

关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：

* BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；
* BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，
* BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；