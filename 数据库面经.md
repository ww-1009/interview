# [MySQL数据库面试题总结](https://blog.csdn.net/adminpd/article/details/122910606)

## 一、数据库设计

### [六大范式](https://blog.csdn.net/weixin_43433032/article/details/89293663)

#### 1. 第一范式 1NF

**定义**： 属于第一范式关系的<font color='red'>所有属性都不可再分</font>，即数据项不可分。

第一范式强调数据表的<font color='red'>原子性</font>，是其他范式的基础。

**规范化**： 一个低一级的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。

#### 2. 第二范式 2NF

**定义**： 若某关系R属于第一范式，且<font color='red'>每一个非主属性完全函数依赖于任何一个候选码</font>，则关系R属于第二范式。

<font color='red'>**候选码**</font>： 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。

*例如在学生表中，学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，主码我们可以随便选定其中一个，则选学号为主码。*

**主属性**： 所有<font color='red'>候选码的属性称为主属性</font>。不包含在任何候选码中的属性称为非主属性或非码属性。

*学生表中，学号和姓名就是该关系的主属性，年龄和性别就是非主属性。*

**函数依赖**： 设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。

**完全函数依赖**： 设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。

![Lapland](https://img-blog.csdnimg.cn/20190414144744240.png "Lapland")

<font color='red'>**判断一个关系是否属于第二范式**</font>：

1. 找出数据表中的所有码；
2. 找出所有主属性和非主属性；
3. 判断所有的非主属性对码的部分函数依赖。

#### 3. 第三范式 3NF

**定义**： 非主属性既不传递依赖于码，也不部分依赖于码。

**理解**： 第三范式要求在满足第二范式的基础上，任何非主属性不依赖于其他非主属性，即在第二范式的基础上，消除了传递依赖。

#### 4. BC范式 BCFN

**定义**： 关系模式R<U,F>中，若每一个决定因素都包含码，则R<U,F>属于BCFN。

**理解**： 根据定义我们可以得到结论，一个满足BC范式的关系模式有：

1. 所有非主属性对每一个码都是完全函数依赖；
2. 所有主属性对每一个不包含它的码也是完全函数依赖；
3. 没有任何属性完全函数依赖于非码的任何一组属性。

*例如有关系模式C(Cno, Cname, Pcno)，Cno, Cname, Pcno依次表示课程号、课程名、选修课。可知关系C只有一个码Cno，且没有任何属性对Cno部分函数依赖或传递函数依赖，所以关系C属于第三范式，同时Cno是C中的唯一决定因素，所以C也属于BC范式。*

#### 5. 第四范式 4NF

**定义**： 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

**理解**： 显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。

#### 6. 第五范式 5NF

1. 必须满足第四范式；
2. 表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。

### 什么是范式和反范式？

| 名称 | 优点 | 缺点 |
|:-------:|:-------:|:-------:|
| 范式 | 范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。 | 查询时通常需要多表关联查询，更难进行索引优化 |
| 反范式 | 反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化 | 存在大量冗余数据，并且数据的维护成本更高 |

## 二、索引

**索引**是对数据库表中一列或多列的值进行排序的数据结构，用于快速访问数据库表中的特定信息。

### 索引分类

1) 从物理结构分为：
   
   * **聚簇索引**指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的**主键索引**；
   * **非聚簇索引**的逻辑顺序则与数据行的物理顺序不一致。
2) 从应用上分为：
   
   * **普通索引**：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 <font color='red'>`ALTER TABLE table_name ADD INDEX index_name (column)`</font> 创建；
   * **唯一索引**：索引列中的值必须是唯一的，但是允许为空值。通过 <font color='red'>`ALTER TABLE table_name ADD UNIQUE index_name (column)`</font> 创建；
   * **主键索引**：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；
   * **组合索引**：组合表中多个字段创建的索引，遵守最左前缀匹配规则；
   * **全文索引**：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。

### 索引优缺点

**优点**

* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
* 加快数据的检索速度
* 加速表和表之间的连接
* 使用分组和排序子句进行数据检索时

**缺点**

* 创建和维护索引需要耗费时间，降低了数据的维护速度
* 索引需要占物理空间

### 索引设计原则

* 选择唯一性索引
* 为常作为查询条件的字段建立索引
* 为经常需要排序、分组和联合操作的字段建立索引
* 限制索引的数目
* 小表不建议索引（如数量级在百万以内）
* 尽量使用数据量少的索引
* 删除不再使用或者很少使用的索引

### 索引的数据结构

MySQL常用 **Hash** 和 **B+ 树**索引

* **Hash 索引**底层就是 <font color='red'>Hash 表</font>，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据.

* **B+ 树索引**底层实现原理是<font color='red'>多路平衡查找树</font>，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询.

#### 1. Hash 和 B+ 树索引的区别
**Hash**

* Hash 进行等值查询更快，但<font color='red'>无法进行范围查询</font>，也不支持使用索引进行排序
* Hash <font color='red'>不支持模糊查询</font>以及多列索引的最左前缀匹配，因为 Hash 函数的值不可预测
* Hash 任何时候都避免不了回表查询数据
* 性能不稳定，因为当某个键值存在大量重复时，产生 Hash 碰撞

**B+ Tree**

* <font color='red'>支持范围查询和排序</font>
* 在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询，不需要回表
* 查询效率比较稳定，因为每次查询都是从根节点到叶子节点，且为树的高度

#### 2. 为何使用 B+ 树而非 B 树做索引

**B+ 树和 B 树的区别：**

* <font color='red'>B 树非叶子结点和叶子结点都存储数据</font>，因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。而 <font color='red'>B+ 树只在叶子结点存储数据，非叶子结点存储关键字</font>，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)
* <font color='red'>B+ 树叶子结点之间用链表相互连接</font>，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B 树只能通过中序遍历

## 三、事务

数据库的**事务**是一个<font color='red'>不可分割</font>的数据库操作序列，也是<font color='red'>数据库并发控制的基本单位</font>，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

**四大特征（ACID）**

* **原子性**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* **一致性**： 事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
* **隔离性**： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
* **持久性**： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
  
**事务的并发问题**

* **脏读：一个事务读取到另一个事务尚未提交的数据。** 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。

* **不可重复读：一个事务中两次读取的数据的内容不一致。** 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。

* **幻读：一个事务中两次读取的数据量不一致。** 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

    <font color='red'>*不可重复读侧重于修改，幻读侧重于新增或删除*</font>

## 
